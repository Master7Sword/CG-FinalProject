# <center>计算机图形学期末大作业-小组报告</center>

## <center>题目：基于OpenGL的3D烟花粒子实时渲染系统</center>

<style>
.center 
{
  width: auto;
  display: table;
  margin-left: auto;
  margin-right: auto;
}
</style>

<div class="center">

| <div style="width: 50px">姓名</div> | 学号 | 分工 |
| ----------------------------------- | --- | --- |
|   莫子昊   | 22331067 | 确定选题与技术路线，构建渲染管线，实现粒子系统，添加烟花音效，场景素材搜集，场景搭建|
|   刘齐诚   | 22336152 | 重构项目代码，制定Code Review标准，贴图素材搜集| 
|   李世源   | 22342043 | 组织项目结构，场景素材搜集，场景导入与渲染，扩展烟花图案| 
|   许睿林   | 22331109 | 优化渲染性能，实现实时渲染| 

</div>

日期：2024.12.31

## 1. 实验概述

本实验在Linux / MacOS下实现了一个基于OpenGL的3D烟花粒子实时渲染系统，旨在通过计算机图形学技术模拟烟花爆炸的视觉效果，并结合音效、光照和场景渲染，提供一个沉浸式的烟花观赏体验。系统通过粒子系统模拟烟花的发射、爆炸和消散过程，并结合摄像机控制、光照模型和场景渲染技术，实现了逼真的3D烟花效果。

### 1.1 **系统架构**
系统主要由以下几个模块组成：

**摄像机模块**：负责摄像机的移动和视角控制，支持通过键盘输入进行前后左右移动以及视角的上下左右调整。

**粒子系统模块**：负责烟花的发射、爆炸和消散过程的模拟。每个烟花粒子具有位置、速度、加速度、颜色、透明度等属性，并根据物理规律进行更新。

**渲染模块**：负责将粒子、场景、天空盒等对象渲染到屏幕上。粒子渲染使用球体模型，并结合透明度衰减实现拖尾效果。

**场景模块**：包括天空盒、地面、神社模型等静态场景元素的加载和渲染，结合光照模型实现逼真的场景效果。

**音效模块**：通过SFML库实现烟花发射和爆炸时的音效播放。


### 1.2 **关键技术**
**粒子系统**：通过模拟烟花粒子的运动轨迹，实现烟花的发射、爆炸和消散效果。粒子在发射阶段沿抛物线上升，达到一定高度后爆炸，生成大量子粒子，子粒子在重力作用下逐渐消散。

**摄像机控制**：通过键盘输入控制摄像机的移动和视角调整，支持WASD键进行前后左右移动，方向键进行视角调整。

**光照模型**：使用点光源模拟烟花爆炸时的光照效果，并结合环境光源实现场景的整体照明。光源的强度和颜色随时间衰减，模拟烟花爆炸后的光晕效果。

**场景渲染**：使用立方体贴图实现天空盒渲染，结合地面和其他模型构建完整的3D场景。地面和其他模型通过纹理贴图和光照模型进行渲染，增强场景的真实感。


综合来说，本项目不仅成功构建了一套带有音效的三维烟花粒子模拟系统，还实现了基于Blinn-Phong光照模型的高精度场景实时渲染。



## 2. 技术路线与方案

### 2.0 写在前面

本项目没有沿用课内作业的Windows + Visual Studio + Qt + qmake的环境配置方案，而是采用Linux / MacOS + GLFW + CMake，原因如下：

- 1、Windows中C++环境配置困难，许多库需要自行下载后添加进环境变量，甚至有些需要自己手动编译，相比之下，Linux和MacOS可以在命令行中一键完成环境配置，极大地提高了项目的开发和复现效率。
- 2、Qt 适合开发复杂的桌面应用，但非常地庞大。而 GLFW 专注于提供窗口管理和 OpenGL 上下文创建，代码库小巧，性能开销小，非常适合实时渲染的任务，同时还支持 Windows、macOS 和 Linux。
- 3、CMake 是 C/C++ 生态中广泛使用的跨平台构建工具，避免了为每个平台单独维护构建脚本的麻烦。同时，CMake 提供了强大的依赖管理功能，可以通过 find_package 轻松集成第三方库，无需手动配置库路径。
  
### 2.1 粒子系统

#### 2.1.1 粒子系统设计目标
粒子系统的核心目标是模拟烟花的发射、爆炸和消散过程，通过控制粒子的位置、速度、加速度、颜色、透明度等属性，实现逼真的烟花效果。具体目标包括：

- **发射阶段**：模拟烟花从地面发射到空中的过程，粒子沿抛物线上升。
- **爆炸阶段**：烟花达到一定高度后爆炸，生成大量子粒子，子粒子向四周扩散。
- **消散阶段**：子粒子在重力作用下逐渐消散，透明度逐渐降低，最终消失。
- **拖尾效果**：在烟花发射和爆炸过程中，生成拖尾粒子，增强视觉效果。

#### 2.1.2 粒子属性设计

每个粒子通过Particle类进行管理，主要属性包括：

- 位置（vec3）
- 方向（vec3）
- 速度（vec3）
- 颜色（vec3）
- 加速度（vec3）
- 透明度（float）
- 生存时间（float）
- 是否已爆炸（bool）
- 是否可回收（bool）
- 是否为拖尾粒子（bool）

#### 2.1.3 粒子更新逻辑
粒子的更新逻辑通过update函数实现，主要包括以下几个步骤：

- **拖尾粒子生成**：如果当前粒子不是拖尾粒子，则在当前位置生成一个拖尾粒子，该拖尾粒子的位置与当前粒子相同，速度和加速度均设为(0.0, 0.0, 0.0)，同时可以通过设置transparency和ttl来控制视觉上的粒子拖尾长度。
- **速度与位置更新**：根据当前速度和加速度更新粒子的位置。加速度由空气阻力和重力共同决定，空气阻力依照公式F=kv来设计，k为空气阻力系数，v为当前速度，这意味着飞行速度越大的粒子所受的阻力越大，符合物理学规律，粒子的飞行轨迹也更贴近现实。
- **爆炸**：如果粒子未爆炸且速度的垂直分量小于阈值，则触发爆炸。爆炸时播放音效，生成爆炸光源，并根据爆炸图案生成大量子粒子。我们受现实世界烟花形状的启发，将下图中这种内外两层的烟花结构实现为基本的烟花形状：
  <br>
  <center>
  <img src="assets/real_firework.png" alt="real_firework" />
  </center>
  <center> 图1.真实世界烟花</center>
  <br>

  它的实现逻辑并不复杂，在产生子粒子时，我们设置其位置与父粒子相同，方向随机，速度为其方向dir\*系数$k$。只要粒子数量足够多，那么许多个随机方向的粒子呈现出来的图案就和真实世界中圆形的烟花一致。我们设置两个系数$k_1$和$k_2$，并使$k_1 < k_2$，让爆炸产生的头n个粒子的速度为dir\*$k_1$，另外n个粒子的速度为dir\*$k_2$，这样就能模拟出上图的效果(烟花粒子的颜色随机)：
  ![simulate_firework](assets/simulate_firework.png)
  <center> 图2.模拟烟花</center>
  <br>

- **透明度与生存时间更新**：根据粒子的状态更新透明度和生存时间。爆炸后的粒子透明度逐渐降低，生存时间逐渐减少。
- **拖尾粒子更新**：拖尾粒子的生存时间和透明度单独更新，透明度降低速度较快，控制拖尾长度在一个合适的范围内。
- **粒子回收**：粒子的回收通过check_recycle函数实现，当粒子的生存时间小于等于0、透明度小于等于0或标记为可回收时，粒子将被回收。回收的粒子从粒子列表中移除，避免不必要的计算和渲染。

#### 2.1.4 粒子系统集成
粒子系统通过Fireworks类进行集成，主要包括以下功能：

- 发射烟花：通过launch函数发射烟花，生成初始粒子并加入粒子列表。
- 更新粒子：通过update函数更新所有粒子的状态，生成新的粒子并回收旧的粒子。
- 渲染粒子：通过render函数渲染所有粒子，使用ParticleRenderer类进行渲染。

#### 2.1.5 图案爆炸效果
在 Particle 类中增加一个属性 pattern 来管理是否爆炸时生成指定图案。通过 Fireworks 类发射时装填的第一颗粒子的 pattern 属性决定这一个烟花的爆炸是否为生成指定图案效果。

图案的信息可以通过已有的图片生成，在 `code/patterns` 下用 python 脚本 opencv 库采样图片信息，生成图案的顶点坐标、颜色信息存储到一个头文件中供 Particle 使用。采样时，生成的坐标需要从图片存储时左上角为坐标原点变换为以图片中心为坐标原点，这样才能使得爆炸时具有从中间开始扩散的效果。同时坐标还需要绕 Y 轴翻转。

Particle 爆炸时，生成的新粒子位置以原来的父粒子坐标 $\vec P_{parent}$ 为基准 Base，加上脚本采样的坐标 $\vec P_{pattern}$ 乘上一个缩小比例 $\alpha$，就是新粒子的初始坐标：

$$
\vec P_0=\vec P_{parent}+\alpha\cdot\vec P_{pattern}
$$

为了保证图案扩散时不变形，不影响视觉效果，可以通过控制新粒子速度大小和方向使其沿着预定路线“扩散”，我们期望它的终点或者说最终被回收时的坐标计算和初始坐标类似，为：

$$
\vec P_1=\vec P_{parent}+\beta\cdot\vec P_{pattern}
$$

其中 $\beta$ 为放大比例。于是计算新粒子的速度为：

$$
\vec v=\frac{\alpha}{\beta}\cdot(\vec P_{1}-\vec P_{0})=\frac{\alpha}{\beta}\cdot(\beta\cdot\vec P_{pattern}-\alpha\cdot\vec P_{pattern})
$$


### 2.2 音效系统

#### 2.2.1 音效系统设计目标
音效系统的核心目标是为烟花发射和爆炸事件提供实时的音效反馈，增强用户的沉浸感。具体目标包括：

- 发射音效：在烟花发射时播放音效，模拟烟花升空的声音。
- 爆炸音效：在烟花爆炸时播放音效，模拟烟花爆炸的声音。
- 音效管理：支持多个音效的同时播放，避免音效冲突或中断。
- 性能优化：确保音效播放的高效性，避免对系统性能造成显著影响。

#### 2.2.2 音效系统架构
本项目的音效系统基于SFML（Simple and Fast Multimedia Library）实现，主要包括以下组件：

- 音效缓冲区（sf::SoundBuffer）：用于加载和存储音效文件的数据。
- 音效实例（sf::Sound）：用于播放音效，每个音效实例绑定一个音效缓冲区。
- 音效管理：通过数组管理多个音效实例，支持音效的循环播放和切换。

#### 2.2.3 音效管理
音效系统的初始化在程序启动时完成，主要包括以下步骤：

- 加载音效文件：通过sf::SoundBuffer::loadFromFile函数加载发射音效（launch.wav）和爆炸音效（explosion.wav）文件。
- 绑定音效实例：将加载的音效缓冲区绑定到sf::Sound实例中，每个音效实例对应一个音效缓冲区。
- 初始化音效索引：设置发射音效和爆炸音效的播放索引（launch_index和explosion_index），用于循环播放音效。


音效的播放逻辑通过processInput函数和Particle::update函数实现，主要包括以下步骤：

- 发射音效播放：当用户按下回车键发射烟花时，播放发射音效。通过launchSound[launch_index].play()函数播放当前索引的音效，并更新索引以循环使用音效实例。
- 爆炸音效播放：当烟花粒子爆炸时，播放爆炸音效。通过explosionSound[explosion_index].play()函数播放当前索引的音效，并更新索引以循环使用音效实例。
  
为了支持多个音效的同时播放，音效系统采用以下管理策略：

- 音效实例数组：使用sf::Sound数组管理多个音效实例，避免单个音效实例的重复播放导致音效中断。
- 音效索引循环：通过launch_index和explosion_index循环使用音效实例，确保每次播放都使用不同的音效实例，避免音效冲突。

#### 2.2.4 性能优化
为了确保音效系统的高效运行，采取了以下优化措施：

- 音效实例预加载：在程序启动时预加载所有音效实例，避免在运行时动态加载音效文件，减少延迟。
- 音效索引管理：通过循环使用音效实例，避免频繁创建和销毁音效实例，减少内存和CPU开销。


### 2.3 场景搭建与实时渲染

#### 2.3.1 场景模型处理与导入

- **烟花粒子模型**
  想要烟花粒子在屏幕上显示出来有几种方案，一个是OpenGL提供的点绘制，另一个是将每个粒子对应为一个实体小球然后将其渲染出来。为了更加真实地模拟粒子的效果，本项目采用blender导出的小球近似模型（共30个面，25个顶点）。小球的渲染不需要纹理，只需要直接给定烟花的颜色，所以实际上只采用了小球的.obj文件，未使用.mtl来采样纹理。
  
![sphere](assets/sphere.png)
<center> 图3.blender构建并导出小球近似模型</center>

- **天空盒模型**
  天空盒是一个立方体，为了更方便地控制天空盒的大小，本项目直接在代码中定义天空盒各个顶点的坐标，并绑定从网上搜集的天空盒贴图素材，通过glDrawArrays绘制天空盒。

![skybox](assets/skybox.png)
<center> 图4.天空盒贴图</center>

- **地面模型**
  与天空盒模型类似，在代码中定义地面模型的顶点坐标、纹理坐标和法线坐标，在定义纹理坐标时可以将其设置为超过[0, 1]范围的浮点数，这样有限大小的纹理会自动重复。
![ground](assets/ground.png)
<center> 图5.地面贴图</center>

- **场景主体模型**
  本项目采用的场景主体是「原神」游戏中稻妻的鸣神大社，素材来源于网络（花了20块从某个网站上买的）。素材原格式为.blend，需要在blender中打开并导出为.obj和.mtl以及对应纹理图片才能用于本项目。在blender的统计信息中可以看到，该场景共有349,796个顶点，592,325条边，284,441个面。

![shrine_blender1](assets/shrine_blender1.png)
<center> 图6.场景主体宏观预览</center>
<br>

![shrine_blender2](assets/shrine_blender2.png)
<center> 图7.场景主体微观预览</center>
<br>
<center>
    <img src="assets/statistics.png" alt="statistics" />
</center>

<center> 图8.场景主体信息统计</center>


#### 2.3.2 场景光源设置

#### 2.3.2.1 光源系统架构
光源系统基于Light结构体实现，主要包括以下属性：

- 位置（position）：光源在场景中的位置。
- 颜色（color）：光源的颜色，用于计算光照效果。
- 强度（intensity）：光源的强度，控制光照的亮度。
- 生存时间（ttl）：光源的生存时间，超过该时间后光源将被移除。

#### 2.3.2.2 静态环境光源
本项目的场景中共有两种环境光源，一种放置在场景主体上方距离较远处以模拟微弱的月光，另一种放置在场景主体各处的灯笼中，模拟灯笼发出的光线。这两种光源的位置与发光强度等信息在代码中固定设置，无需动态更新。

#### 2.3.2.3 动态粒子光源
在烟花爆炸时生成动态光源，光源的位置和颜色与爆炸粒子一致。光源的更新逻辑通过Fireworks::update函数实现，主要包括以下步骤：

- 光源强度衰减：根据时间衰减光源的强度，模拟光晕逐渐消失的效果。
- 光源生存时间更新：减少光源的生存时间，当生存时间小于等于0时，光源将被移除。
- 光源移除：通过std::remove_if函数移除生存时间结束或强度衰减为0的光源。

#### 2.3.3 实时渲染

本项目渲染管线的流程分为以下两个阶段：

##### 1.初始化阶段
- **窗口与上下文初始化**：通过GLFW创建窗口并初始化OpenGL上下文。
- **GLEW初始化**：加载OpenGL扩展函数，确保现代OpenGL功能可用。
- **深度测试启用**：启用深度测试（glEnable(GL_DEPTH_TEST)），确保物体正确遮挡
资源加载：加载模型、纹理、着色器等资源，初始化场景对象（如天空盒、地面、鸣神大社模型等）。

##### 2.主循环阶段

- **计算帧时间**：通过glfwGetTime获取当前时间，计算与上一帧的时间差，用于控制动画、物理模拟和摄像机移动的速度。
- **处理输入**：通过processInput函数处理用户输入（如摄像机移动、烟花发射），更新摄像机位置和视角。
- **清屏**：使用glClear清除颜色缓冲区和深度缓冲区，准备渲染新帧。
- **渲染固定背景**：天空盒、地面以及鸣神大社
- **更新粒子系统**：更新烟花粒子的状态（位置、速度、颜色等），生成新的粒子和光源，移除已失效的粒子和光源。
- **渲染粒子系统**：使用ParticleRenderer渲染所有烟花粒子，应用颜色和透明度效果。
- **交换缓冲区与事件处理**：使用glfwSwapBuffers交换前后缓冲区，将渲染结果显示到屏幕上，使用glfwPollEvents处理窗口事件（键盘、鼠标输入）。

##### 实现实时渲染的关键技术

- 1、**顶点数据传输**
    使用顶点缓冲对象（VBO），将顶点数据存储在GPU的显存中，避免每一帧都从CPU传输数据。具体来说，使用glGenBuffers生成VBO，接着使用glBindBuffer绑定VBO，最后使用glBufferData将顶点数据上传到GPU。
- 2、**纹理数据传输**
    使用stb_image库加载纹理文件，使用glGenTextures生成OpenGL纹理对象，在渲染时使用glBindTexture绑定纹理到着色器，最后使用glTexImage2D将纹理数据上传到GPU，支持漫反射、自发光和透明度贴图。此处最核心的优化是实现了**纹理批次渲染**，在初始化时根据材质对顶点数据进行分组，在渲染时按纹理批次绑定纹理并绘制。相比于没有实现纹理批次渲染，在渲染35w个顶点主体模型时的帧率在使用了纹理批次渲染后提升了10倍。
- 3、**光照数据传输**
    使用glUniform将光源数据传递到着色器，在着色器中根据光源数据计算光照效果。
- 4、**矩阵数据传输**
    包括模型矩阵、视图矩阵和投影矩阵。使用glUniformMatrix4fv将矩阵数据传递到着色器，在着色器中根据矩阵数据计算顶点的最终位置。
- 5、**粒子数据传输**
    包括位置、颜色、透明度等信息。使用glBufferData将粒子数据上传到GPU，在着色器中根据粒子数据计算渲染效果。

## 3. 实验效果

### 3.1 静态场景展示

在定义地面模型的顶点信息时，我们可以手动控制纹理的重复次数，本项目设置其为200，以使得每个地面石砖的大小看起来比较合适。
![static_ground](assets/static_ground.png)
<center> 图9.地面贴图展示</center>
<br>

接下来从不同角度展示一下未发射烟花的场景，为了能够看的比较清楚，可以手动在片元着色器中拉高环境光、漫反射和镜面反射的权重。由于我们在每个挂着的灯笼处手动添加了光源，所以在接近灯笼处可以观察到明显的高光:

![static_1](assets/static_1.png)
<center> 图10.宏观场景展示_1</center>
<br>

![static_2](assets/static_2.png)
<center> 图11.宏观场景展示_2</center>
<br>

![static_3](assets/static_3.png)
<center> 图12.微观场景展示_1</center>
<br>

![static_4](assets/static_4.png)
<center> 图13.微观场景展示_2</center>
<br>

![static_5](assets/static_5.png)
<center> 图14.微观场景展示_3</center>
<br>

### 3.2 动态场景展示

为了模拟燃放烟花时的夜晚场景，将场景的整体亮度降低。由于烟花爆炸时会产生光源，可以观察到场景靠近烟花爆炸中心的一面会较为明亮：

![dynamic_1](assets/dynamic_1.png)
<center> 图15.动态场景展示_1</center>
<br>

![dynamic_2](assets/dynamic_2.png)
<center> 图16.动态场景展示_2</center>
<br>

![dynamic_3](assets/dynamic_3.png)
<center> 图17.动态场景展示_3</center>
<br>

![dynamic_4](assets/dynamic_4.png)
<center> 图18.动态场景展示_4</center>
<br>

![dynamic_5](assets/dynamic_5.png)
<center> 图19.动态场景展示_5</center>
<br>

![dynamic_6](assets/dynamic_6.png)
<center> 图20.动态场景展示_6</center>
<br>

### 3.3 自定义烟花形状展示

![maomaochong](assets/maomaochong.png)
<center> 图21.自定义猫猫虫</center>
<br>

![long](assets/long.png)
<center> 图22.自定义龙图</center>
<br>

![msc](assets/msc.png)
<center> 图23.中山大学互联网与开源技术协会会标</center>
<br>

### 4. 总结与展望

在本实验中，我们成功实现了一个基于OpenGL的3D烟花粒子实时渲染系统，通过粒子系统、摄像机控制、光照模型、场景渲染和音效管理等技术的综合应用，模拟了烟花从发射到爆炸再到消散的完整过程，并结合静态场景和动态光源，提供了沉浸式的烟花观赏体验。以下是本次实验的主要成果与收获：

#### 4.1 主要成果
**粒子系统的实现**：通过设计粒子属性、更新逻辑和回收机制，成功模拟了烟花的发射、爆炸和消散过程。爆炸时生成的子粒子通过随机方向和速度控制，实现了逼真的烟花效果。此外，通过自定义图案爆炸效果，进一步扩展了烟花的表现形式，能够生成如猫猫虫等复杂图案。

**音效系统的集成**：利用SFML库实现了烟花发射和爆炸时的音效播放，并通过音效实例数组和索引循环管理，确保了多个音效的同时播放，增强了系统的沉浸感。

**场景搭建与实时渲染**：通过导入复杂的场景模型（如鸣神大社）并结合天空盒、地面等静态元素，构建了一个完整的3D场景。通过Blinn-Phong光照模型和动态光源的引入，实现了场景的高精度渲染。特别是在渲染性能优化方面，通过纹理批次渲染、顶点数据传输等技术，显著提升了系统的实时渲染效率。

**摄像机控制与交互**：通过键盘输入实现了摄像机的自由移动和视角调整，用户可以自由探索场景，并从不同角度观赏烟花效果。

### 4.2 改进方向

1. 本实验完整地搭建了烟花粒子的模拟/渲染框架，但是仅实现了几种烟花样式，而现实世界中的烟花种类繁多，我们其实还可以扩展出更多的烟花样式。

2. 用户交互体验还可以改进，现在的烟花发射是在一定区域内的随机位置、速度和颜色，最好可以让用户自行决定烟花的各个属性。
